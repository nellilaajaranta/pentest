# h2 Totally Legit Sertificate

Tero Karvisen [Tunkeutumistestaus 2023-kurssin](https://terokarvinen.com/2023/tunkeutumistestaus-2023-kevat/) h2-tehtäväraporttini.

## Lue ja tiivistä: PortSwigger: [SQL injection](https://portswigger.net/web-security/sql-injection), PortSwigger: [Cross-site scripting](https://portswigger.net/web-security/cross-site-scripting)

- SQL injektio on verkkohaavoittuvuus, jonka avulla hyökkääjä pääsee käsiksi sovelluksen tekemiin tietokantakyselyihin. Hyökkääjä voi saada pääsyn arkaluontoisiin tietoihin, kuten salasanoihin, maksukorttitietoihin tai muihin henkilökohtaisiin käyttäjätietoihin. SQL injektiota voi hyödyntää laajasti erityyppisissä haavoittuvuuksissa ja tekniikoissa, esimerkiksi:
- piilotetun datan haku, jossa SQL kyselyä muokataan lisätietojen saamiseksi
- sovelluksen logiikan kumoaminen, jossa kyselyä muokataan niin, että se muuttaa sovelluksen toimintaperiaatetta
- UNION-hyökkäykset, joissa dataa voi hakea eri tietokantatauluista 
- tietokannan tarkastelu, jossa saa poimittua tietoa tietokannan versiosta ja rakenteesta
- blind/sokea SQL injektio, jossa kyselyn tuloksia ei palauteta sovellukselle.

- Cross-site scripting (XSS) on verkkohaavoittuvuus, jonka avulla hyökkääjä pystyy syöttämään haitallista koodia sivustolle, josta kys. koodi päätyy käyttäjän selaimeen. XSS voidaan käyttää esiintymään uhri-käyttäjänä, tekemään toimintoja mitä käyttäjä pystyy, lukemaan käyttäjän tietoja, keräämään käyttäjän kirjautumustietoja, tai lisäämän verkkosivulla troijalaisen. Erityyppisiä hyökkäyksiä ovat

-  Reflected XSS, jossa haitallinen koodi tulee nykyisestä HTTP-pyynnöstä
sovellus saa dataa HTTP-pyynnöstä ja sisällyttää kys. datan vastauksessa, -> haitallinen koodi "heijastuu" kertaalleen, kun kyttäjä avaa hyökkääjän linkin
-  Stored XSS, jossa haitallinen koodi tulee sivuston tietokannasta
Sovellus saa dataa epäluotettavasta lähteestä ja ja sisällyttää kyseisen epäluotettavan datan myöhemmissä HTTP-vastauksissa.
-  DOM-based XSS, jossa haavoittuvuus sijaitsee client-puolen koodissa
JavaScript hakee dataa epäluotettavasta lähteestä, 

## a) ZAP! Asenna ZAP välimiesproxy ja näytä, että pystyt sieppaamaan liikennettä selaimesta.

Latasin Linux installerin [ZAP:in verkkosivuilta](https://www.zaproxy.org/download/)

Avasin Linuxin terminaalin ja menin cd-komennolla sijaintiin, jossa juuri lataamani ZAP-asennustiedosto (shell-script) on. Kokeilin asentaa sen seuraavalla komennolla:

`sudo ./ZAP_2_12_0_unix.sh`

Asennus ei kuitenkaan onnistunut, sillä kys. scriptillä ei ole execute-oikeuksia. Seuraava komento antaa käyttäjälle execute-oikeudet kys. scriptiin:

`chmod u+x ZAP_2_12_0_unix.sh`

Nyt scriptin ajo onnistui ja ZAP:n installer avautui. Valitsin standard-asennuksen.

![zapasennus](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/ZAPasennus.jpg)

ZAPin kautta saa käynnistettyä Firefoxin, jolloin ZAPin kautta saa seurattua selaimen liikennettä:

![zap](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/zapasennettu.jpg)

## b) Totally Legit Sertificate. Asenna ZAP:n generoima CA-sertifikaatti selaimeen ja osoita testillä, että pystyt sieppaamaan HTTPS-salakirjoitettua liikennettä.

ZAP:ssa Tools -> options -> network -> server sertificates saa luotua CA sertifikaatin generate-painikkeesta:

![generate](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/generatesertificate.jpg)

Ylläolevasta ilmoituksesta painoin yes. Tämän jälkeen tallensin sertifikaatin save-painikkeesta paikkaan, mistä sen helposti löytää. 

Seuraavaksi avasin Firefoxin ja avasin setifikaattiasetukset, sijainti settings -> privacy and security -> certificates

![firefoxcertificates](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/firefoxcertificate.jpg)

Avautuvasta ikkunasta valitsin aiemmin tallentamani sertifikaatin, ja sen jälkeen tulevasta kyselystä "trust this to identify websites". Nyt sertifikaatti on asetettu:

![cert](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/owaspcert.jpg)

Tämän jälkeen uudelleenkäynnistin Firefoxin ja kokeilin availla sivuja, mutta ZAP ei näyttänyt mitään -  löysin [ohjevideon](https://www.youtube.com/watch?v=IdpIBXrAgQQ) jossa firefoxin proxy-asetuksia tulisi muuttaa vastaamaan ZAP:n asetuksia: general -> network settings -> manual proxy configuration, http-proxy 127.0.0.1. & port 8888

![proxy](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/proxysettings.jpg)

Liikenteen sieppaus:

![sieppaus](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/zaphttps.jpg)

## d) Vuohi. Asenna WebGoat ja kokeile, että pääset kirjautumaan sisään.

Käytin apuna [Tero Karvisen ohjetta](https://terokarvinen.com/2020/install-webgoat-web-pentest-practice-target/) WeGoatin asennukseen.

Ajoin seuraavat komennot:

`sudo apt-get update`
`sudo apt-get -y install openjdk-11-jre ufw wget bash-completion`

^Javan asennus

`sudo ufw enable`

^Palomuurin käyttöönotto

`wget https://terokarvinen.com/2020/install-webgoat-web-pentest-practice-target/webgoat-server-8.0.0.M26.jar`
`java -jar webgoat-server-8.0.0.M26.jar`

^WebGoatin lataus ja asennus

Avasin WebGoatin selaimessa osoitteella http://localhost:8080/WebGoat/ ja loin uuden käyttäjän.

Nyt WebGoat on asennettu ja kirjautuminen onnistuu:

![WebGoat](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/webgoat%20asennettu.jpg)

## e) Vauvavuohi. Ratkaise WebGoatista tehtävät "HTTP Basics" ja "Developer tools". Katso vinkit alta.

HTTP Basics:

Tehtävä 3 ratkaisua varten menin takaisin teht. 2, lähetin nimen "testi" ja katsoin selaimen developer toolsin network-välilehdeltä mitä tapahtuu - pyynnön lähettäessä tulee POST-HTTP-komento, joka sisältää syötetyn tekstin.

![input field](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/form_data.jpg)

Magic number löytyy teht.3 avaamalla developer toolsin, ja inspevtor-välilehdellä hakemalla magic_num:

![magic num](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/macig_Num.jpg)

^ylläolevassa kuvassa näkyy, että kys. tapauksessa magic number on 75.

Developer Tools:

![phonehome](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/phonehome.jpg)

![networknum](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/networknum.jpg)

HTTP basics & DevTools tehty:

![done](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/babygoat%20done.jpg)

## f) SELECT * FROM student. Ratkaise SQLZoo:sta: 0 SELECT basics

![SELECT1](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/basics%201.png)

![SELECT2](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/basics%202.png)

![SELECT3](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/basics%203.png)

## 2 SELECT from World kohdat 1-5.

![SELECTWORLD1](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/select%201.png)

![SELECTWORLD2](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/select%202.png)

![SELECTWORLD3](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/select%203.png)

![SELECTWORLD4](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/select%204.png)

![SELECTWORLD5](https://github.com/nellilaajaranta/pentest/blob/main/pictures/h2/select%205.png)

## g) Ratkaise WebGoatista*:

#### A1 Injection (intro)

Tehtävässä käytettävä taulu, josta SQL-kyselyt haetaan:

KUVA

	2. Ylläolevasta taulusta tulee hakea työntekijän "department", osasto. Käytin userid:tä nimen sijaan, sillä id tunnistaa haettavan yksilön paremmin kuin nimi, mikäli taulussa olisi samannimisiä.

KUVA

	3. Työntekijän Tobi Barnett osasto tulee muuttaa 'Sales'. Käytin apuna WebGoatin Hints-painiketta kyselyn muodostukseen:

Kuva hints

KUVA

	4. Employees-tauluun lisätään phone-kolumni:

KUVA

	5. Käyttäjäryhmälle "UnauthorizedUser" lisätään oikeus muokata tauluja:

KUVA


	9. Kysely, joka hakee kaikki käyttäjät users-taulusta:

KUVA

Kuvasta näkyy, että tehtävässä on selitetty miksi kysely toimii: '1'='1' on aina tosi, ja ehtolauseen (OR) vuoksi kysely päätyy tulokseen true, eikä sitä edeltävillä ehdoilla ole merkitystä.

	10. Tehtässä täytyi käyttää kahta lomakekenttää kyselyn luomiseen, jolla hakea kaikki data users-taulusta. Kokeilin ensin kirjoitta satunnaisia arvoja nähdäkseni mitä tapahtuu, mutten saaut juuri mitään irti vastauksesta - katsoin lopulta WebGoatin hints-vihjeistä neuvoja:

Kuva

Kokeilin vihjeen neuvoa 0 or 1 = 1 ensin ensimmäiseen kenttään, joka ei tehnyt mitään. Seuraavaksi kokeilin sitä alempaan kenttään, joka toimi (tällöin yläolevassa kentässä täytyi olla vain numeroita):

KUVA

	11. Tehtävässä täytyy uudelleen kahta lomekekenttää käyttäen muodostaa kysely, jonka avulla työntekijä pystyisi päästä käsiksi sisäisen järjestelmän kaikkiin tietoihin. Tämä onnistui hyvin samankaltaisella ratkaisulla kuin aikaisempi:
KUVA

	12. Tehtävässä tuli muokata työntekijän John Smith palkkaa korkeammaksi. Käytin apuna WebGoatin hints-vihjeitä:

KUVA 

Koko kysely:

`3SLA99A'; UPDATE employees SET salary = '90000' WHERE = userid = '37648`

KUVA Lopuksi tehtävässä täytyi poistaa access_log niminen taulu, jotta aiemmin tehdyt muutokset eivät paljastuisi. Tämä onnistui yksnkertaisella kyselyllä perustuen aikaisempiin oppeihin:

`'; DROP TABLE access_log; --`

KUVA

#### A2 Broken authentication: Authentication bypasses: 2 2FA Password Reset

Tehtävässä tulee kiertää kaksivaiheinen tunnistus (2fa). Tehtävän yhteydessä oli esimerkki https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass, jossa proxyn avulla poistettiin turvakysymykset kaksivaiheisesta tunnsituksesta.

Tehtävää varten käynnistin siis ZAP:n, jotta saan kokeiltua esimerkin tapaa. Pysäytin liikenteen zapin vihreästä ympyrästä ja syötin kenttiin tekstiä, ZAP sai tämän tallennettua:

KUVA

Kokeilin ensin esimerkin tekniikkaa ja poistin turvakysymykset.

KUVA

Tämä ei toiminut, joten katsoin vihjeistä apuja, josta selvisi ettei parametreja tule poistaa vaan muokata. Tämä toimi:

KUVA

#### A3 Sensitive data exposure: Insecure Login: 2 Let's try


Tehtävässä tuli seurata liikennettä ja painaa login-nappia. Katkaisin liikenteen ZAP:ssa ja näkyviin tuli seuraavat tiedot:

KUVA

Saadut kirjautumistiedot toimivat:

KUVA


#### A7 Cross Site Scripting (XSS): Cross site scripting

##### 2. What is XSS?

Tehtävässä tuli avata kahdella eri välilehdellä webgoatin nykyinen verkko-osoite, ja sitten kirjoittaa selaimen osoitekenttään `javascript:alert(document.cookie);` ja tarkistaa, ovatko evästeet samat kahdella eri välilehdellä. Tämä ei toiminut Firefoxissa (ei tapahtunut mitään), joten kokeilin chromella. Chromella tämä toimi ja välilehtien evästeet ovat samat:

KUVA

KUVA

##### 7 Try It! Reflected XSS

Käytin komennon muodostamiseen apuna tehtävässä X) lue ja tiivistä - tarvittua [Portswiggerin artikkelia](https://portswigger.net/web-security/cross-site-scripting), ja kokeilin seuraavaa komentoa luottokorttinumero-kenttään:

`<script>/alert()</script>`

Tämä toimi:

KUVA

#### A8:2013 Request Forgeries: Cross-Site Request Forgeries

##### 3 Basic Get CSRF Exercise

KUVA 

Tehtävässä täytyi saada alemmpaan lomakkeeseen kysely suoritettua ulkoisesta lähteestä. En päässyt tehtävässä eteenpäin vihjeiden avulla, joten löysin ohjeen [Medium.com-sivustolta](https://medium.com/@evidencemonday/webgoat-cross-site-request-forgery-solution-1c069985e80f). Ohjeen mukaan täytyy luoda uusi HTML-tiedosto, jonka tarkoitus on imitoida webgoatin csrf-tiedostoa, joka avautuu submit query-napista.

Uuden csrf.html -tiedoston koodi, lähde medium.com/Evidence Monday (HUOM. Localhost-osoitteen porttinumeron tulee vastata webgoatin porttinumeroa):

<html>
<body>
<form action=" http://localhost:8080/WebGoat/csrf/basic-get-flag" method="POST">
<input name="csrf" value="false" type="hidden">
<input name="submit" type="hidden" value="submit-Query">
<input type="submit" value="Submit">
</form>
</body>
</html>

Tiedosto tuli avata selaimessa. Siitä avautui sivu, jossa on submit-nappi - tätä painamalla pyyntö onnistuu ja saa flag numberin, omassa tapauksessani nro 8278.

KUVA

Syötin numeron WebGoatin lomakkeeseen ja se hyväksyttiin.

KUVA

##### 4 Post a review on someone else’s behalf

Tehtävässä täytyi luoda arvostelu ulkoisesta lähteestä tuotteiden arviointi-sivustolle. Käytin apuna samaa  [Medium.com-](https://medium.com/@evidencemonday/webgoat-cross-site-request-forgery-solution-1c069985e80f) ohjetta kuin aikaisemmassa tehtävässä. 

Tehtävä on hyvin samankaltainen kuin edellinen, tulee luoda erillinen HTML-tiedosto, lähde medium.com/Evidence Monday:

<html>
<body>
 <form action="http://localhost:8080/WebGoat/csrf/review" method="POST">
  <input name="reviewText" value="Kiva juttu" type="hidden">
  <input name="stars" type="hidden" value="5">
  <input name="validateReq" type="hidden" value="2aa14227b9a13d0bede0388a7fba9aa9">
  <input type="submit" value="Submit">
 </form>
</body>
</html>

Juuri luomani uuden csrf.html-tiedostosta avautui uudelleen selaimessa submit-nappi-näkymä, jota painaessa tuli ilmoitus, että tehtävä on suoritettu onnistuneesti.

KUVA

Tämän jälkeen päivitin WebGoatin tehtäväsivun, jossa arvostelu tuli näkyviin:

KUVA







